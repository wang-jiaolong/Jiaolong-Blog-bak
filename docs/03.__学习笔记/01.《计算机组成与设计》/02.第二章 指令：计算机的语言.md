---
title: 第二章 指令：计算机的语言
date: 2022-07-23 18:18:05
permalink: /pages/935f86/
hidden: true

---

## 指令系统

- 设计原则1：简单源于规整。
- 设计原则2：更少则更快。

- 设计原则3：优秀的设计需要适当的折中。

## 计算机硬件的操作



## 有符号数与无符号数

无符号数：

![image-20220725161510072](https://s2.loli.net/2022/07/25/325wWZvSmoielQC.png)

有符号数

![image-20220725161545914](https://s2.loli.net/2022/07/25/f2XDZIQ4xdliP3k.png)

![image-20220725161606828](https://s2.loli.net/2022/07/25/UCkXwrMLEqeycxT.png)

> 二进制补码表示的优点是，所有负数的最高有效位都为1。因此，硬件只需要检测这一位就可以查看是正数还是负数（数字O被认为是正数）。这个位通常被称为符号位(sign bit)。理解了符号位的作用，就可以用每位数值乘以2的幂之和来表示正负数的64位数：



**相反数**

![image-20220725161813679](https://s2.loli.net/2022/07/25/vFPHuZ5K8IdhTRb.png)



## 机器中的指令表示

对于

```assembly
add x9, x20, x21
```

十进制指令表示为

![image-20220725162536164](https://s2.loli.net/2022/07/25/KZ2k7umtFAps6MB.png)



一条指令的每一段称为一个字段。第一、第四和第六个字段(0、0和51)组合起来告诉RISC-V计算机该指令执行加法操作。第二个字段给出了作为加法运算的第二个源操作数的寄存器编号(21表示x21)，第三个字段给出了加法运算的另一个源操作数(20代表x20)。第五个字段存放要接收总和的寄存器编号(9代表x9)。因此，该指令将寄存器x20和寄存器x21相加并将和存放在寄存器x9中。

该指令也可表示为二进制的形式：

![image-20220725162638369](https://s2.loli.net/2022/07/25/HQCmK2cUP3Rakd6.png)



### RISC-V字段

#### R型

![image-20220725162753452](https://s2.loli.net/2022/07/25/lm7RyD1gdtAWqrI.png)



- funct7:一个另外的操作码字段。
- rs2:第二个源操作数寄存器。

- rs1：第一个源操作数寄存器。
- funct3：一个另外的操作码字段。
- rd：目的操作数寄存器，用来存放操作结果。
- opcode(操作码)：指令的基本操作，这个缩写是它的惯用名称。

#### I型

> 用于带一个常数的算术指令（例如addi)以及加载指令。

![image-20220725163606316](https://s2.loli.net/2022/07/25/ANoLzbYP8eTaUSO.png)

12位immediate字段为补码值，所以它可以表示从-2到2m-1之间的整数。当I型格式用于加载指令时，immediate字段表示一个字节偏移量，所以加载双字指令可以取相对于基址寄存器d中基地址偏移±(21或2048)字节（±(2或256）个双字)的任何双字。我们发现，超过32个寄存器在这种格式下使用起来会很困难，因为rd和rs1字段都需要增添额外的一位，这导致一个字是不够的。



#### S型

> 用于存储双字指令sd的指令格式，它需要两个源寄存器（用于基址和存储数据)和一个用于地址偏移量的immediate字段。

![image-20220725163824001](https://s2.loli.net/2022/07/25/j4ZfCxYuzGpcwPS.png)

S型格式的12位immediate字段分成了两个字段，低5位和高7位。RISC-V体系结构设计师选择这种设计是因为它能够在所有指令格式中保持rs1和rs2字段在相同的位置。保持尽可能相似的指令格式降低了硬件的复杂性。同样，opcode和funct.3字段也总是保持同样的大小并在同一个位置。



![image-20220725172616305](https://s2.loli.net/2022/07/25/NOVhGMEpW3TXs48.png)

![image-20220725172629561](https://s2.loli.net/2022/07/25/EIi6AST1FugxXny.png)

#### SB型

> RISC-V分支指令使用称为SB型的RISC-V指令格式。这种格式可以表示从-4096到094的分支地址，以2的倍数表示。由于最近的一些原因，它只能跳转到偶数地址。SB型格式包括一个7位操作码、一个3位功能码、两个5位的寄存器操作数(rs1和s2)和一个12位地址立即数。该地址使用特殊的编码方式，简化了数据通路设计，但使组装变得复杂。

如：

```assembly
bne x10, x11, 2000	//if x10 != x11, go to location 2000 = 011111010000_ten
```

可以组装为这种格式

![image-20220726150639110](https://s2.loli.net/2022/07/26/52VN8A1746wbXpW.png)

其中条件分支的操作码是1100111_2，而`bne`的funct3码是001_2。



#### UJ型

> 无条件跳转-链接指令(ja1)是唯一使用UJ型格式的指令。

该指令由一个7位操作码、一个5位目标寄存器操作数(rd)和一个20位地址立即数组成。链接地址，即ja1之后的指令的地址，被写入rd中。与SB型格式一样，UJ型格式的地址操作数使用特殊的立即数编码方式，它不能编码奇数地址。所以，

```ass
jal x0, 2000	//go to 1ocation 2000_ten=0111 1101 0000
```

被组装为这种格式：

![image-20220726151242386](https://s2.loli.net/2022/07/26/CIRhjt71qHn8c4Q.png)



#### 总结

![image-20220726152748569](https://s2.loli.net/2022/07/26/hZQVAnEOKL4sbH7.png)





## 汇编代码

### 基础运算

**相加操作：**

```c
a = b + c + d + e
```

编译后：

```assembly
add a, b, c		// The sum of b and c is placed in a
add a, a, d		// The sum of b,c,and d is now in a
add a, a, e		// The sum of b,c,d,and e is now in a
```



**复杂赋值语句**

```c
f = ( g + h ) - ( i + j );
```

编译后：

```assembly
add t0, g, h	// temporary variable t0 contains g h
add t1, i, j	// temporary variable tl contains i+j
sub f, t0, tl	// f gets to tl,which is (g h)-(i j)
```



**操作数在内存中**

```c
A[12] = h + A[8];
```

编译后：

假设变量h存放在寄存器x21中，数组A的基址存放在寄存器x22中。

```assembly
1d x9, 64(×22)	// Temporary reg x9 gets A[8]
add x9, x21,x9	// Temporary reg x9 gets h A[8]
sd x9, 96(x22)	// Stores h A[8]back into A[12]
```

> 字节寻址也会影响数组下标。为了在上面的代码中获得正确的字节地址，加到基址寄存器×22的偏移量必须是8×8或64，以便取地址将选择A[8]而不是[8/8]。



**常数**

> 我们需要将常数从内存中取出才能使用

例如，要将常数4加到寄存器×22，可以使用以下代码：

假设x3+AddrConstant4是常数4的内存地址。

```assembly
ld x9 .AddrConstant4(x3)	// x9 constant 4
add x22, x22, x9			// x22 = x22 + x9 (where x9 == 4)
```

或使用立即数

```assembly
addi x22, ×22, 4	// ×22 = x22 + 4
```



### 逻辑操作

- AND（于）：两个操作数的逻辑按位操作，只有在两个操作数中的对应位都是1时，结果的对应位才是1。

  ```assembly
  and x9, x10, x11	//reg x9 reg x10 reg x11
  ```

- OR（或）：两个操作数的逻辑按位操作，如果两个操作数中的对应位有一个为1，则结果的对应位为1。

  ```assembly
  or x9, x10, x11		//reg x9 reg x10 reg x11
  ```

- NOT（按位取反）：一个操作数的逻辑按位取反操作，也即是说，把每个1替换为0，把每个0替换为1。

- XOR（异或）：两个操作数的逻辑按位操作，用于计算两个操作数的异或。也就是说，只有两个操作数的对应位不同时，它才会计算为1。

  > 为了保持三操作数格式，RISC-V的设计者决定引入指令XOR(异或)来取代NOT。因为异或是在两个操作数对应位相同时设0，不同时设1，所以NOT等价于异或111.…111。

  ```
  xor x9, x10, x12 		//reg x9 reg x10 reg x12
  ```

  

### 条件分支

**相等则分支**

```assembly
beq rs1, rs2, L1
```

该指令表示如果寄存器rs1中的值等于寄存器rs2中的值，则转到标签为L1的语句执行。助记符`beq`代表相等则分支。

**不等则分支**

```
bne rsl, rs2, L1
```

该指令表示如果寄存器rs1中的值不等于寄存器rs2中的值，则转到标签为L1的语句执行。助记符`bne`代表不等则分支。



例如：

在下面的代码段中，f、g、h、i和j是变量。如果五个变量f到j对应于x19到x23这5个寄存器，

```c
if ( i == j ) 
    f = g + h; 
else 
    f = g - h;
```

![image-20220726105459824](https://s2.loli.net/2022/07/26/4DZbdL7ijrOBPC3.png)

代码如下：

```assembly
bne x22, x23, E1se		//go to Else if i≠j
add x19, x20, x21		//f = g + h (skipped if i≠j)
beg x0, x0, Exit		//if 0 =0,go to Exit
Else: sub x19, x20, x21	//f = g - h (skipped if i = j)
Exit:
```

第一个表达式比较寄存器中两个变量是否相等。如果i和j相等则跳转，那么需要一条beq指令。一般来说，如果我们测试相反的条件来进行跳转，代码将更有效率，那么需要一条bne指令。

if语句的结尾部分,本例引入了另一种分支，通常称为无条件分支。该指令表示在遇到该指令时，程序必须分支。在RISC-V中表达无条件分支的一种方法是使用条件始终为真的条件分支。

在该指令之后还需Exit标签，表示if-then-else编译后的代码结束.。



### 移位

一个双字中的所有位都向左或向右移，用填充空出来的位。对应于左移的是右移。这两条RISC-V移位指令的实际名称是左移逻辑立即数(slli)和右移逻辑立即数(srli)。

```
s11i x11, x19, 4	// reg xll = reg x19 << 4 bits
```

表示9，并且9×16=144，刚好是第二个二进制的值。RISC-V提供了第三种类型的移位招令—算术右移(srai)。这个变体与srli很相似，但它不是用零填充空出的左边的位而是用原来的符号位来填充。它还提供了三个移位操作的变体：sll、srl和sra。它们从寄存器中取出移位的位数，而不是从立即数中。

### 循环

对于常见while循环

```c
while ( save[i] == k )
	i += 1;
```

假设`i`和`k`对应于寄存器x22和x24，数组的基址保存在x25中。

```assembly
Loop: 
s11i x10, x22, 3	// 左移3位相当于乘以2^3,获取偏移量,存放在临时寄存器x10中
add x10, x10, x25		// 和数组基址相加得到save[i]的地址
1dx 9, 0(x10)			// 把save[i]的值取出 放在x9里
bne x9, x24, Exit		// 如果save[i]≠k 则退出
addi x22, x22, 1		// i = i + 1
beq x0, x0, Loop 		// 继续循环
Exit:
```

第一步是将save[i]加载到临时寄存器中。在将save[i]加载到临时寄存器之前，需要得到它的地址。在将i加到数组save的基址以形成地址之前，由于字节寻址问
题，必须将索引i乘以8。幸运的是，我们可以使用左移，因为左移3位相当于乘以2^3(参见上一节)。我们需要给指令添加标签Loop，以便我们可以在循环结尾跳转回该指令。

### 边界检查

利用该简便方法可以降低下标越界检查的开销：如果x20≥×11或×20是负数则跳转到`IndexoutofBounds`。

```assembly
bgeu x20, x11, IndexOutofBounds 
```

### case/switch语句

大多数编程语言都包含case或switch语句，允许程序员根据某个值选择多个分支中的一个。实现switch的最简单方法是通过一系列的条件测试，将switch语句转换成if-then-else语句。

有时，另一种更有效的方法是编码形成指令序列的地址表，称为分支地址表或分支表，程序只需要索引到表中，然后跳转到合适的指令序列。因此，分支表只是一个双字数组，其中包含与代码中的标签对应的地址。该程序将分支表中的相应条目加载到寄存器中，然后需要使用寄存器中的地址进行跳转。为了支持这种情况，RISC-V这类指令系统包含一个间接跳转指令，该指令对寄存器中指定的地址执行无条件跳转。在RISC-V中，跳转一链接指令(jalr)用于此目的。我们将在下一节中看到这种多功能指令更多常见的使用方式。

> 虽然在类似C和Java这样的编程语言中有很多决策和循环的语句，但在指令系统级别实现它们的基础语句是条件分支。

## 计算机硬件对过程的支持

### 过程（函数）

程序执行过程时，须遵循

1. 将参数放在过程可以访问到的位置。
2. 将控制转交给过程。
3. 获取过程所需的存储资源。
4. 执行所需的任务。
5. 将结果值放在调用程序可以访问到的位置。
6. 将控制返回到初始点，因为过程可以从程序中的多个点调用。

RISC-V软件为过程调用分配寄存器时遵循以下约定：

- x10~x17：八个参数寄存器，用于传递参数或返回值。
- x1：一个返回地址寄存器，用于返回到起始点。

除了分配这些寄存器之外，RISC-V汇编语言还包含一个仅用于过程的指令：跳转到某个地址的同时将下一条指令的地址保存到目标寄存器rd。跳转-链接指令(jal)写作：
```
jal x1, ProcedureAddress		//jump to ProcedureAddress and write return address to xl
```

> 跳转一链接指令：跳转到某个地址的同时将下一条指令的地址保存在寄存器（在RISC-V中通常是x1）中的指令。

指令中的链接部分表示指向调用点的地址或链接，以允许该过程返回到合适的地址。存储在寄存器x1中的这个“链接”被称为返回地址。返回地址是必需的，因为同一过程可能在程序的不同部分被调用。为了支持这种情况下的过程返回，类似RISC-V的计算机使用了间接跳转（如上述跳转-链接指令(jalr)),用以处理case语句：

```assembly
jalr x0, 0(x1)
```

> 详细阐述通过使用x作为目标寄存器，跳转-链接指令也可用于实现过程内的无条件跳转。由于×0硬连线为零，其效果是丢弃返回地址：
>
> ```assembly
> jal x0, Label 	//unconditionally branch to Label
> ```

### 使用更多的寄存器

假设对于一个过程，编译器需要比8个参数寄存器更多的寄存器。由于在任务完成后必须掩盖踪迹，调用者所需的所有寄存器都必须恢复到调用该过程之前所存储的值。这种情况是需要将寄存器换出到存储器中的一个例子。

换出寄存器的理想数据结构是**栈(stack)**——一种后进先出的队列。栈需要一个指向栈中最新分配地址的指针，以指示下一个过程应该放置换出寄存器的位置或寄存器旧值的存放位置。在RISC-V中，栈指针(stack pointer)是寄存器x2,也称为`sp`。栈指针按照每个被保存或恢复的寄存器按双字进行调整。栈应用非常广泛，因而传送数据到栈或从栈传输数据都具有专业术语：将数据放入栈中称为压栈，从栈中移除数据称为弹栈。

按照历史惯例，栈按照从高到低的地址顺序“增长”。这就意味着可以通过减栈指针将值压栈；通过增加栈指针缩小栈，从而弹出栈中的值。

如一段c的函数

```c
long long int leaf_example (long long int g,longlong,int h,long long int i,long long int j){
	long long int f;
	f = ( g + h ) - ( i + j );
	return f:
}
```

编译后：

参数变量g、h、i和j对应于参数寄存器×10、x11、x12和x13,f对应于x20。

下一步是保存该过程使用的寄存器。过程体中的赋值语句与之前的例题相同，使用两个临时寄存器(x5和×6)。因此，需要保存三个寄存器：×5、×6和x20。通过在栈中创建三个双字(24字节)空间并将数据存入，实现将旧值“压”入栈中：

```assembly
leaf_example:
addi sp, sp, -24	//在栈中创建空间
sd x5, 16(sp)		//将数据存入栈中
sd x6, 8(sp)
sd x20, 0(sp)
add x5, x10, x11 	//函数体内运算
add x6, x12, x13
sub x20, x5, x6
addi x10, x20, 0 	// 为了返回f，把值复制到一个参数寄存器中
1d x20, 0(sp)		//恢复寄存器的三个旧值：
1d x6, 8(sp)
1d x5, 16(sp)
addi sp, sp, 24		//调整栈大小来删除栈中的临时数据
jalr x0, 0(x1)		//通过一个使用返回地址的跳转寄存器结束过程
```

> 先前示例使用了临时寄存器，并假设其旧值必须被保存和恢复。为了避免保存和恢复一个其值从未被使用过的寄存器（通常为临时寄存器），RISC-V软件将19个寄存器分成两组：
>
> - x5~x7以及x28~×31:临时寄存器，在过程调用中不被被调用者（被调用的过程）保存。
>
> - x8~x9以及x18~x27:保存寄存器(saved register),在过程调用中必须被保存。(一旦使用，由被调用者保存并恢复)
>
>   这一简单约定减少了寄存器换出。在上述例子中，由于调用者不希望在过程调用中保存寄存器×5和6,可以从代码中去掉两次存储和两次载入。但仍须保存并恢复×20，因为被调用者必须假设调用者需要该值。

### 嵌套过程

> 叶子过程：不调用其他过程的过程称为叶子(leaf)过程。

如果所有过程都是叶子过程，情况将会变得简单，但事实并非如此。正如一个侦探任务的一部分可能是雇佣其他侦探一样，被雇佣的侦探进而雇佣更多的侦探，过程调用其他过程也是如此。更进一步，递归过程甚至调用的是自身的“克隆”。就像在过程中使用寄存器时需要小心一样，在调用非叶子过程时必须更加注意。例如，假设主程序调用过程A,参数为3，将值3存入寄存器x10然后使用ja1x1,A。再假设过程A通过ja1x1,B调用过程B,参数为7，也存入x10。由于A尚未结束任务，所以寄存器x10的使用存在冲突。同样在寄存器x1中的返回地址也存在冲突，因为它现在具有的返回地址。除非采取措施阻止这类问题发生，否则该冲突将导致过程A无法返回其调用者。一种解决方法是将其他所有必须保存的寄存器压栈，就像保存寄存器压栈一样。调用者将所有调用后还需要的参数寄存器(x10~x17)或临时寄存器(x5~x7和x28~x31)压栈。被调用者将返回地址寄存器×1和被调用者使用的保存寄存器(x8~×9和x18~x27)压栈。调整栈指针SD以计算压栈寄存器的数量。返回时，从存储器中恢复寄存器并重新调整栈指针。

处理一个计算阶乘的递归过程：



处理一个计算阶乘的递归过程：

```c
long long int fact (long long int n)
{
	if (n < 1)	return (1);
	else return ( n * fact( n - 1 ));
}
```

RISC-V汇编代码：

答案参数变量n对应参数寄存器x10。编译后的程序从过程的标签开始，然后在栈中保存两个寄存器，返回地址和×10：

```assembly
fact:
addi sp,sp,-16
sd x1,8(sp)
sd x10,0(sp)
```

第一次调用fact时，sd保存程序中调用fact的地址。下面两条指令测试n是否小于1，如果n≥1则跳转到L1。

```assembly
addi x5,x10,-1		//x5=n-1
bge x5, x0, L1		//if(n-1)>=0,g0t0L1
```

如果n小于1，fact将1放入一个值寄存器中以返回1：它将1加0并将和存入x10中。然后从栈中弹出两个已保存的值并跳转到返回地址：

```assembly
addi x10, x0, 1 	//return 1
addi sp, sp, 16		//pop 2 items off stack
jalr x0, 0(x1)		//return to caller
```

在从栈中弹出两项之前，可以加载x1和x10。因为当小于1时x1和x10不会改变，所以跳过这些指令。

如果n不小于1，则参数n递减，然后用递减后的值再次调用fact

```assembly
L1:
addi x10, x10,-1 	//n >1:argument gets (n -1)
jal x1,fact		//call fact with (n -1)
```

下一条指令是fact的返回位置，其结果在x10中。现在旧的返回地址和旧的参数与栈指针一起被恢复：

```assembly
addi x6, x10, 0		//return from jal:move result of fact(n-1) t0 x6:
1d x10, 0(sp)		//restore argument n
1d x1, 8(sp)		//restore the return address
addi sp, sp, 16		//adjust stack pointer to pop 2 items
```

接下来，参数寄存器x10得到旧参数与fact(n-1)结果的乘积，目前在x6中。假设有一个乘法指令可用，尽管在第3章才会涉及：

```
mul x10, x10, x6		//return n fact (n -1)
```

最后，fact再次跳转到返回地址：

```assembly
jalr x0, 0(x1)		//return to the caller
```

## 人机交互

### ASCII

计算机的发明是为了数字计算，但很快被用于商业方面的文本处理。当前大多数计算机使用字节来表示字符，也就是每个人都遵循的表示方法ASCII(American Standard Code for InformationInterchange)。图2-15总结了ASCII码。

![image-20220727111336546](https://s2.loli.net/2022/07/27/MPWOfXCwTJ289EN.png)

### Unicode

Unicode是大多数人类语言中字母表的通用编码。图2-16给出了Unicode字母表的列表，Unicode中的字母表几乎与ASCII中的有用符号一样多。为了更具包容性，Java将Unicode用于字符。默认情况下，它使用16位来表示一个字符。

![image-20220727111432085](https://s2.loli.net/2022/07/27/GEKDW6Vi1YmBOUA.png)

RISC-V指令系统具有加载和存储这种16位半字的指令。load half unsigned(加载无符号半字)从内存中读取一个半字，将它放在寄存器的最右边16位，用零填充最左边的48位。与加载字节一样，加载半字(1h)将半字视为有符号数，因此进行符号扩展以填充寄存器的最左边48位。存储半字(sh)从寄存器的最右边16位取半字并将其写入内存。我们按下面的序列来复制一个半字：

```
lhu x19, 0(x10)	//Read halfword (16 bits)from source
sh 	x19, 0(x11)	//Write halfword (16 bits)to dest
```

字符串是标准的Java类，具有专门的内置支持和用于连接、比较和转换的预定义方法。与C语言不同，Java包含一个给出字符串长度的字，类似于Java数组。

### 复制字节

一系列指令可以从双字中提取一个字节，因此对双字的加载和存储足以传输字节和字。但由于某些程序中文本的流行，所以RISC-V提供了字节转移指令。加载无符号字节(lbu)指令从内存加载一个字节，将其放在寄存器的最右边8位。存储字节(sb)指令从寄存器的最右边8位取一个字节并将其写入内存。因此，我们复制一个字节的顺序如下：

```
1bu 12, 0(x10)	//Read byte from source
sb x12, 0(x11)	//Write byte to destination
```

字符通常组合成具有可变数量的字符串。字符串的表示有三种选择：

(1)字符串的第一个位置保留，用于给出字符串的长度；

(2)附加带有字符串长度（如在结构体中）的变量；

(3)字符串的最后位置用一个字符标记字符串结尾。

C语言使用第三种选择，使用值为0的字节终止字符串（在ASCII中命名为null)。因此，字符串“Cal”在C语言中用以下4个字节表示，十进制数表示为67、97、108和0。（下面我们将看到，Java使用第一个选项。）

如C语言的复制

`strcpy`过程将字符串y复制到字符串x,C语言使用null字节标记字符串结束：

```c
void strcpy (char x[], char y[])
{
	size_t i;
	i = 0;
	while x[i] = y[i]) != '\0')		//copy test byte *
		i+=1;
}
```

编译后：

假设数组×和y的基址存放在×10和x11中，而i在x19中。strcpy调整栈指针，然后将保存的寄存器x19保存在栈中：

```assembly
strcpy:
addi sp,sp,-8	//adjust stack for 1 more item
sd x19, 0(sp)	//save x19
```

将i初始化为0，下一条指令通过0加0将×19设为0并将结果放在×19中：

```
add x19,x0,x0	//i=0+0
```

这是循环的开始。y[i]的地址首先通过将i加到y[]来形成：

```
L1: add x5, x19, x11 	//address of y[i]in x5
```

注意，我们不必将i乘以8，因为y是字节数组而不是双字，如前面的例子中那样。
为了加载y[i]中的字符，我们使用无符号加载字节，将字符放入x6中：

```
lbu x6, 0(x5)	//x6=y[i]
```

类似的地址计算将x[i]的地址放在x7中，然后x6中的字符存储在那个地址中。

```
add x7,x19,x10	//address of x[i]in x7
sb x6,0(x7)		//x[i]=y[i]
```

接下来，如果字符为，则退出循环。也就是说，如果它是字符串的最后一个字符，我们退出：

```
beq x6, x0,L2
```

如果不是，递增i继续循环：

```
addi x19,x19,1	//i=i+1
jal x0,L1		//go to L1
```

如果不继续循环，它就是字符串的最后一个字符；我们恢复×19和栈指针，然后返回。

```assembly
L2:1d
x19,0(sp)		//restore old x19
addi sp, sp,8	//pop 1 doubleword off stack
jalr x0,0(x1)	//return
```

由于上面的`strcpy`过程是一个叶过程，编译器可以将i分配给临时寄存器并避免保存和恢复x19。因此，我们可以将它们视为被调用者在方便的时候可使用的寄存器，而不是将这些寄存器视为临时寄存器。当编译器找到一个叶过程时，它会在使用必须保存的寄存器之前耗尽所有临时寄存器。



## 对大立即数的RISC-V编址和寻址

虽然将所有RISC-V指令保持32位长可以简化硬件，但有时候使用32位或更大的常量或地址会很方便。本节从较大常量的一般解决方案开始，然后描述了分支指令中使用的指令地址优化。

### 大立即数

虽然常量通常很短并且适合12位字段，但有时它们也会更大。RISC-V指令系统包括指令load upper immediate(取立即数高位，1ui),用于将20位常数加载到寄存器的第31位到第12位。将第31位的值复制填充到最左边32位，最右边的12位用0填充。例如，这条指令允许使用两条指令创建32位常量。1ui使用新的指令格式一一U型，因为其他格式不能支持如此大的常量。

## RISC-V寻址模式总结

![image-20220726151506642](https://s2.loli.net/2022/07/26/yU628lEMTuBQOZ5.png)

1. 立即数寻址，操作数是指令本身的常量。
2. 寄存器寻址，操作数在寄存器中。
3. 基址或偏移寻址，操作数于内存中，其地址是寄存器和指令中的常量之和。
4. PC相对寻址，分支地址是PC和指令中常量之和。

## 机器语言译码

> 有时必须通过逆向工程将机器语言恢复到初始的汇编语言。例如发生“内存转储”(coredump)时。图2-18显示了RISC-V机器语言对应的二进制编码。这个图有助于在汇编语言和机器语言之间进行手动翻译。

![image-20220726151731223](https://s2.loli.net/2022/07/26/oP4bM7zqGOWvFEp.png)

例：

与下面这条机器指令对应的汇编语言语句是什么？
00578833_16

第一步是将十六进制转换为二进制：

0000 0000 0101 0111 1000 1000 0011 0011

要知道如何解释这些位，我们需要确定指令格式，为此首先需要确定操作码。操作码是最右边的7位，即011 0011。在图2-18中搜索该值，我们看到操作码对应于R型算术指令。因此，我们可以将二进制格式解析为下图中列出的字段：

![image-20220726152119561](https://s2.loli.net/2022/07/26/8aDWyqMQ9GsEpid.png)

我们通过查看字段值来译码指令的剩余部分。funct7和funct3字段均为零，表示指令是加法。操作数寄存器rs2字段的十进制值为5，rs1为15，rd为16。这些数字代表寄存器x5、x15和x16。现在我们可以得到汇编指令：

```assembly
add x16, x15, x5
```



## 指令与并行性：同步

当任务之间相互独立时，并行执行更为容易，但通常任务之间需要协作。协作通常意味着一些任务正在写入其他任务必须读取的值。需要知道任务何时完成写入以便其他任务安全地读出，因此任务之间需要同步。如果它们不同步，则存在**数据竞争(data race**)的危险，那么程序的结果会根据事件发生的次序而改变。

> 数据竞争：如果来自两个不同的线程的访存请求访问同一个位置，至少有一个是写，且连续出现，那么这两次存储访问形成了数据竞争。

我们从原子交换(atomic exchange或atomic swap)原语开始，展示如何使用它来构建基本同步原语。它是构建同步机制的一种典型操作，它将寄存器中的值与存储器中的值进行交换。

为了了解如何使用它来构建基本同步原语，假设要构建一个简单的锁变量，其中值用于表示锁变量可用，值1用于表示锁变量已被占用。处理器尝试通过将寄存器中的1与该锁变量对应的内存地址的值进行交换来设置加锁。如果某个其他处理器已声明访问该锁变量，则交换指令的返回值为1，表明该锁已被其他处理器占用，否则为，表示加锁成功。在后一种情况下，锁变量的值变为1，以防止其他处理器也加锁成功。

例如，考虑两个处理器尝试同时进行交换操作：这种竞争会被阻止，因为其中一个处理器将首先执行交换，并返回，而第二个处理器在进行交换时将返回1。使用交换原语实现同步的关键是操作的原子性：交换是不可分割的，硬件将对两个同时发生的交换进行排序。尝试以这种方式设置同步变量的两个处理器都不可能认为它们同时设置了变量。实现单个的原子存储操作为处理器的设计带来了一些挑战，因为它要求在单条不可中断的指令中完成存储器的读和写操作。
另一种方法是使用指令对，其中第二条指令返回一个值，该值表示该指令对是否被原子执行。如果任何处理器执行的所有其他操作都发生在该对指令之前或之后，则该指令对实际上是原子的。因此，当指令对实际上是原子操作时，没有其他处理器可以在指令对之间改变值。

在RISC-V中，这对指令指的是一个称为保留加载(load-reserved)双字(`lr.d`)的特殊加载指令和一个称为条件存储(store-conditional)双字(`sc.d`)的特殊存储指令。这些指令按序使用：如果保留加载指令指定的内存位置的内容在条件存储指令执行到同一地址之前发生了变化，则条件存储指令失败且不会将值写人内存。条件存储指令定义为将（可能是不同的)寄存器的值存储在内存中，如果成功则将另一个寄存器的值更改为，如果失败则更改为非零值。因此，`sc.d`指定了三个寄存器：一个用于保存地址，一个用于指示原子操作失败或成功，还有一个用于如果成功则将值存储在内存中。由于保留加载指令返回初始值，并且条件存储指令仅在成功时返回0，因此以下序列在寄存器×20中指定的内存位置上实现原子交换：

```
again:Ir.d x10,(x20)	//load-reserved
sc.dx11,x23,(x20) 		//store-conditional
bne x11,x0,again		//branch if store fails
addi x23,x10.0			//put loaded value in x23
```

每当处理器干预并修改`lr.d`和`sc.d`指令之间的内存中的值时，`sc.d`就会将非零值写入×11，从而导致代码序列重新执行。在此序列结束时，×23的值和x20指向的内存位置的值发生了原子交换。

## 翻译并启动程序

![image-20220726155742597](https://s2.loli.net/2022/07/26/tbhiVT2r6XQlLIB.png)

### 编译器

编译器将程序转换为机器能理解的符号形式——汇编语言程序(assembly language program)。高级语言程序比汇编语言使用更少的代码行，因此程序员的工作效率更高。

### 汇编器

由于汇编语言是高层软件的接口，因此汇编器还可以处理机器指令的常见变体，就像这些变体是它自己的指令一样。硬件不需要实现这些指令；然而，它
们在汇编语言中的出现简化了程序转换和编程。这类指令称为伪指令。

如上所述，RISC-V硬件确保寄存器xO总是取O。也就是说，每当使用寄存器×0时，它提供0，如果程序员尝试更改x0中的值，则新值会被直接丢弃。寄存器×用于创建汇编语言指令，将一个寄存器的内容复制到另一个寄存器。因此，即使在RISC-V机器语言中不存在这条指令，RISC-V汇编器也能够识别以下指令：

```assembly
1i x9, 123			//load immediate value 123 into register x9
```

汇编器将此汇编语言指令转换为与以下指令等效的机器语言：

```assembly
addi x9, x0, 123 	//register x9 gets register x0 + 123
```

RISC-V汇编器还将`mv(move)`转换为`addi`指令。从而

```assembly
mv x10, x11 		//register x10 gets register x11
```

变为

```assembly
addi x10, x11, 0 	//register x10 gets register x11 + 0
```

汇编器还接受j Labe1作为ja1x0,Label的替代，无条件跳转到标签位置。它还将跳转到远距离的分支指令转换为一个分支指令和一个跳转指令。如上所述，RISC-V汇编器允许将大常量加载到寄存器中，尽管立即数指令的位数有限。因此，上面介绍的load immediate(li)伪指令可以创建大于addi的立即数字段可包含的常量；加载地址(la)宏对符号地址的工作方式类似。最后，它可以通过确定程序员想要的指令变体来简化指令系统。例如，算术和逻辑指令使用常量时，RISC-V汇编器不要求程序员指定指令的立即数版本，它只是生成正确的操作码。从而将

```
and x9,x10,15 		//register x9 gets x10 AND 15
```

变为

```
andi x9,x10,15 		//register x9 gets x10 AND 15
```

我们在指令中包含“i”以提醒读者，andi与没有立即数操作数的and指令不同，具有不同的指令格式，会生成不同的操作码。

总之，伪指令为RISC-V提供了比硬件实现更丰富的汇编语言指令系统。如果要编写汇编程序，请使用伪指令来简化任务。但是，要了解RISC-V体系结构并确保获得最佳性能，请学习图2-1和图2-18中真正的RISC-V指令。

汇编器也会接收不同基数的数字。除了二进制和十进制之外，它们通常接收比二进制更简短又很容易转换为位模式的基数。RISC-V汇编器使用十六进制和八进制.

这种特性非常方便，但汇编器的主要任务是汇编成机器代码。汇编器将汇编语言程序转换为目标文件(object file),该目标文件是机器指令、数据和将指令正确放入内存所需信息的组合。

为了在汇编语言程序中产生每条指令的二进制版本，汇编器必须确定与所有标签相对应的地址。汇编器会跟踪分支中使用的标签和符号表中的数据传输指令。正如你所料，该表由符号和对应地址成对组成。



UNIX系统的目标文件通常包含六个不同的部分：

- 目标文件头，描述了目标文件的其他部分的大小和位置。
- 代码段，包含机器语言代码。
- 静态数据段，包含在程序生命周期内分配的数据(UIX允许程序使用静态数据，它在整个程序中都存在；也允许使用动态数据，它可以根据程序的需要增长或缩小。见图2-13。)
- 重定位信息，标记了在程序加载到内存时依赖于绝对地址的指令和数据。
- 符号表，包含剩余的未定义的标签，例如外部引用。
- 调试信息，包含有关如何编译目标模块的简明描述，以便调试器可以将机器指令与源文件相关联并使数据结构可读。



### 链接器

> 链接器：也叫链接编辑器，是一个系统程序，它将独立汇编的机器语言程序组合起来，并解析所有未定义的标签，最终生成可执行文件。

链接器的工作有三个步骤：

1. 将代码和数据模块按符号特征放入内存。
2. 决定数据和指令标签的地址。
3. 修正内部和外部引用。

链接器生成可在计算机上运行的可执行文件。通常，此文件具有与目标文件相同的格式，但它不包含任何未解析的用。具有部分链接的文件是可能的，例如库程序，在目标文件中仍然有未解析的地址。

### 加载器

> 加载器：将目标程序放在主存中以准备执行的系统程序。

现在可执行文件在磁盘上，操作系统将其读取到内存并启动它。加载器在UX系统中
遵循以下步骤：

1. 读取可执行文件首部以确定正文段和数据段的大小。
2. 为正文和数据创建足够大的地址空间。
3. 将可执行文件中的指令和数据复制到内存中。
4. 将主程序的参数（如果有）复制到栈顶。
5. 初始化处理器寄存器并将栈指针指向第一个空闲位置。
6. 跳转到启动例程，将参数复制到参数寄存器中并调用程序的主例程。当主例程返回时，启动例程通过exit系统调用终止程序。

### 动态链接库

> 动态链接库：在执行期间链接到程序的库例程。

其库例程在程序运行之前不会被链接和加载。程序和库例程都保存有关非局部过程及其名字的额外信息。在DLL的最初版本中，加载器运行一个动态链接程序，使用文件中的额外信息来查找相应的库并更新所有外部引用。

DLL初始版本的缺点是，它仍然链接了可能被调用的库的所有例程，而不是在程序运行期间调用的那些例程。这种观察引出了DLL的延迟过程链接版本，其中每个例程仅在被调用之后才链接。

像这个领域的许多创新一样，这项技巧依赖于一个间接层次。图2-21展示了这种技术。它从非局部例程开始，在程序结束时调用一组虚例程，每个非局部例程有一个入口。每个虚入口都包含一个间接跳转。

![image-20220727114137124](https://s2.loli.net/2022/07/27/gyTuCn3Z5vIRa7D.png)

第一次调用库例程时，程序调用虚入口并执行间接跳转。这个跳转指向一段代码，它将一个数字放入寄存器来识别所需的库例程，然后跳转到动态链接器/加载器。链接器/加载器找到所需的例程，重新映射它，并更改间接跳转位置中的地址以指向该例程。然后跳转到这个例程。例程完成后，它将返回到初始调用点。此后，它都会间接跳转到该例程而不需额外的中间过程。

总之，DLL需要额外的空间来存储动态链接所需的信息，但不要求复制或链接整个库。它们在第一次调用例程时会付出大量的开销，但此后只需一个间接跳转。请注意，从库返回不会产生额外的开销。微软的Windows广泛依赖动态链接库，如今UNIX系统上程序执行的默认设置也是使用动态链接库。

## 以C排序程序为例

### swap过程

此过程是交换内存中的两个位置。当手动把C程序翻译成汇编语言时，我们遵循以下步骤：

1. 为程序中的变量分配寄存器。
2. 为过程体生成汇编代码。
3. 保存过程调用间的寄存器。

```c
void swap(long long int v[],size_t k)
{
	long long int temp:
	temp = v[k]:
	v[k] = v[k+1];
	v[k+1] = temp;
}
```

**swap的寄存器分配**

如2.8节中所述，RISC-V的参数传递默认使用寄存器x10到x17。由于swap只有两个参数ⅴ和k,因此可以在寄存器×10和×11中保存。唯一的一个变量是temp,我们用寄存器x5来保存它，因为SwaD是一个叶过程（参见2.8.2节）。该寄存器分配对应于图2-23中swap过程第一部分的变量声明。

回想一下，RISC-V的内存地址是字节寻址，因此双字实际上相差8个字节。因此，在将索引k与地址相加之前，需要将索引k乘以8。忘记相邻的双字地址间相差8而不是1是汇编语言编程中常见的错误。因此，第一步是通过左移3位使k乘8以得到v[k]的地址：

我们使用x6加载v[k],然后通过向x6加8来加载v[k+1]:

我们将x5和x7中的值存储到交换的地址：

完整汇编：

```assembly
swap:
s11i x6, x11, 3		//reg x6=k *8
add x6, x10, x6		//regx6=v+(k*8)
ld x5, 0(x6)		//reg x5 (temp)=v[k]
ld x7, 8(x6)		//reg x7 = v[k + 1]
sd x7, 0(x6)		//v[k] reg x7
sd x5, 8(x6)		//v[k+1] reg x5 (temp)
jalr x0, 0(x1)		//return to calling routine
```

### sort过程

为了确保读者能够理解汇编语言中编程的严谨性，我们将尝试第二个更长的示例。在这种示例中，我们将构建一个调用swap过程的例程。这个程序使用冒泡或交换排序对整数数组进行排序，这是最简单的排序之一，但不是最快的排序。图2-24显示了该程序的C语言版本。我们还是以几个步骤介绍此程序，并在最后将它们组合到一起。

```c
void sort (long long int v[],size_t int n){
	sizet i,j;
	for( i = 0; i < n : i += 1){
		for( j = i - 1; j >= 0 && v[j] > v[j+1]; j -= 1 ){
			swap(v,j);
		}
	}
}

```

**sort的寄存器分配**

过程sort的v和n两个参数保存在参数寄存器x10和x11中，我们将寄存器x19分配给i,并将x20分配给j。

**sort过程体的代码**

过程体由两个嵌套的for循环和一个包含参数的swap调用组成。让我们从外而内展开代码。

第一个翻译步骤是第一个for循环：

```
for(i=0;i<n;i+=1){
```

回想一下，C的for语句有三个部分：初始化、循环判断和循环增值。只需要一条指令就可以将i初始化为0，这是for语句的第一部分：

```
li x19, 0
```

(请记住，1是汇编器为了方便汇编语言程序员而提供的伪指令；请参阅2.12.2节。)它只需要一条指令来递增i,即for语句的最后一部分：

```
addi x19, x19, 1	//i+=1
```

如果 i < n 非真，则应该退出循环，换句话说，如果i≥，则应该退出。此判断只需一条
指令：

```
forltst: bge x19, x11, exitl	//go to exitl if x19 >= x1 (i >= n)
```

循环的底部只是跳转回到循环判断处：

```
	j forltst					//branch to test of outer loop
exitl:
```

那么第一个for循环的代码框架是

```
1i x19, 0			//i=0
forltst:
bge x19, x11, exit1	//go to exitl if x19 2 x1 (i2n)
...
(body of first for loop)
...
	addi x19, x19, 1	//i+=1
	j forltst		//branch to test of outer loop
exitl:
```

第二个for循环的C语句如下：

```
for ( j = i - 1; j >= 0 && v[j] > v[j+1]; j -= 1){
```

该循环的初始化部分仍然是一条指令：

```
addi x20, x19, -1	//j=i-1
```

循环结束时j的自减也是一条指令：

```
addi x20, x20, -1 	//j-=1
```

循环判断有两个部分。如果任一条件为假，我们退出循环，因此如果第一个判断(j<)为假则必须退出循环：

```
for2tst: blt x20, x0, exit2 q//go to exit2 if x20 0 (j<0)
```

该分支将跳过第二个条件判断。如果没有跳过，则j≥0。

如果第二个判断v[j]>v[j+1]非真，或者如果v[j]≤v[j+1],则退出。首先，我们通过将j乘以8（因为我们需要一个字节地址）来创建地址并将其加到v的基址上：

```
s11i x5, ×20, 3		//reg x5 =j*8
add x5, x10, x5		//regx5=v+(j*8)
```

现在我们加载v[j]:

```
1d x6, 0(x5)		//reg x6 v[j]
```

因为我们知道第二个元素是紧跟的一个双字，所以，将寄存器x5中的地址加8，得到

```
v[j+1]: 1d x7, 8(×5)	//reg x7 v[j +1]
```

我们判断v[j]≤v[j+1]以退出循环：

```
ble x6, x7, exit2	//go to exit2 i fx6 ≤ x7
```

循环的底部跳转回到内循环判断处：

```
j for2tst			//branch to test of inner loop
```

将这些部分结合到一起，第二个for循环的代码框架是这样的：

```
addi x20,x19,-1		//j=i-1
for2tst:
blt x20,x0,exit2 	//go to exit2 if x20 0 (j <0)
s11i x5, ×20, 3		//reg x5=j*8
add x5,x10,x5		//regx5=v+(j*8)
ld x6,0(x5)			//reg x6 =v[j]
1d x7,8(×5)			//reg x7-v[j 1]
ble x6,x7,exit2		//g0 to exit2ifx6≤x7
...
(body of second for loop)
...
addi x20,x20,-1		//j-=1
j for2tst			//branch to test of inner loop
exit2:
```

**sort中的过程调用**

下一步是翻译第二个for循环的循环体：

```
swap(v,j);
```

调用swap很容易：

```
jal x1, swap
```

**sort中的参数传递**

当传递参数时问题就出现了，因为s0t过程需要寄存器x10和x11中的值，但swa过程需要将其参数放在那些相同的寄存器中。一种解决方案是在过程较早的地方将
s0rt中的参数复制到其他寄存器中，使得寄存器x10和x11在调用swap时可用。（这个复制比在栈上保存和恢复更快。)我们首先在过程中将x10和×11复制到×21和×22：

```
mv x21,x10		//copy parameter x10 into x21
mv x22,x11		//copy parameter x11 into x22
```

然后用这两个指令将参数传递到swap:

```
mv x10,x21		//first swap parameter is v
mv x11,x20		//second swap parameter is j
```

**保留sort中的寄存器**

唯一剩下的代码是寄存器的保存和恢复。显然，我们必须在寄存器x1中保存返回地址，因为s0rt是一个过程并且调用自己。s0t过程还使用被调用者保存的寄存器x19、x20、x21和x22,因此必须保存它们。所以sort的过程头如下：

```
addi sp,sp,-40		//make room on stack for 5 regs
sd x1,32(sp)		//save xl on stack
sd x22,24(sp) 		//save x22 on stack
sd x21,16(sp)		//save x21 on stack
sd x20,8(sp)		//save x20 on stack
sd x19,0(sp)		//save x19 on stac
```

过程尾简单地反转所有这些指令，然后加一个ja1r以便返回。

**完整的sort过程**

现在我们将所有部分放在一起，如图2-25所示，注意在fo循环中用寄存器x21和×22替换对寄存器x10和×11的引用。再一次，为了使代码更容易理解，我们用过程中的每个代码块的用途来标识它们。在此示例中，C中的9行sort过程在RISC-V汇编语言中变为34行。

```assembly
sort: 
addi sp,sp,-40		//make room on stack for 5 regs
sd x1,32(sp)		//save xl on stack
sd x22,24(sp) 		//save x22 on stack
sd x21,16(sp)		//save x21 on stack
sd x20,8(sp)		//save x20 on stack
sd x19,0(sp)		//save x19 on stac
mv x21,x10		//copy parameter x10 into x21
mv x22,x11		//copy parameter x11 into x22
1i x19,0		//1=0
for1tst: bge x19, x22, exitl	//go to exit1 if i>=n
addi x20,x19,-1		//j=i-1
for2tst:
blt x20,x0,exit2 	//go to exit2 if x20 0 (j <0)
s11i x5, ×20, 3		//reg x5=j*8
add x5,x10,x5		//regx5=v+(j*8)
ld x6,0(x5)			//reg x6 =v[j]
1d x7,8(×5)			//reg x7-v[j 1]
ble x6,x7,exit2		//g0 to exit2ifx6≤x7
mv x10,x21		//first swap parameter is v
mv x11,x20		//second swap parameter is j
jal x1, swap
addi x20,x20,-1		//j-=1
j for2tst			//branch to test of inner loop
exit2:
addi x19, x19, 1	//i+=1
j forltst		//branch to test of outer loop
exitl:
1d x19,0(sp)		//restore x19 from stack
1d x20,8(sp)		//restore x20 from stack
1d x21,16(sp)	//restore x21 from stack
1d x22,24(sp)	//restore x22 from stack
1d x1,32(sp)	//restore return address from stack
addi sp,sp,40	//restore stack pointer
jalr x0,0(x1)	//return to calling routine
```

