---
title: 第二章 指令：计算机的语言
date: 2022-07-23 18:18:05
permalink: /pages/935f86/
categories: 
  - null
tags: 
  - null
author: 
hidden: true
---

## 指令系统

- 设计原则1：简单源于规整。
- 设计原则2：更少则更快。

- 设计原则3：优秀的设计需要适当的折中。

## 计算机硬件的操作



## 有符号数与无符号数

无符号数：

![image-20220725161510072](https://s2.loli.net/2022/07/25/325wWZvSmoielQC.png)

有符号数

![image-20220725161545914](https://s2.loli.net/2022/07/25/f2XDZIQ4xdliP3k.png)

![image-20220725161606828](https://s2.loli.net/2022/07/25/UCkXwrMLEqeycxT.png)

> 二进制补码表示的优点是，所有负数的最高有效位都为1。因此，硬件只需要检测这一位就可以查看是正数还是负数（数字O被认为是正数）。这个位通常被称为符号位(sign bit)。理解了符号位的作用，就可以用每位数值乘以2的幂之和来表示正负数的64位数：



**相反数**

![image-20220725161813679](https://s2.loli.net/2022/07/25/vFPHuZ5K8IdhTRb.png)



## 机器中的指令表示

对于

```assembly
add x9, x20, x21
```

十进制指令表示为

![image-20220725162536164](https://s2.loli.net/2022/07/25/KZ2k7umtFAps6MB.png)



一条指令的每一段称为一个字段。第一、第四和第六个字段(0、0和51)组合起来告诉RISC-V计算机该指令执行加法操作。第二个字段给出了作为加法运算的第二个源操作数的寄存器编号(21表示x21)，第三个字段给出了加法运算的另一个源操作数(20代表x20)。第五个字段存放要接收总和的寄存器编号(9代表x9)。因此，该指令将寄存器x20和寄存器x21相加并将和存放在寄存器x9中。

该指令也可表示为二进制的形式：

![image-20220725162638369](https://s2.loli.net/2022/07/25/HQCmK2cUP3Rakd6.png)



### RISC-V字段

#### R型

![image-20220725162753452](https://s2.loli.net/2022/07/25/lm7RyD1gdtAWqrI.png)



- funct7:一个另外的操作码字段。
- rs2:第二个源操作数寄存器。

- rs1：第一个源操作数寄存器。
- funct3：一个另外的操作码字段。
- rd：目的操作数寄存器，用来存放操作结果。
- opcode(操作码)：指令的基本操作，这个缩写是它的惯用名称。

#### I型

> 用于带一个常数的算术指令（例如addi)以及加载指令。

![image-20220725163606316](https://s2.loli.net/2022/07/25/ANoLzbYP8eTaUSO.png)

12位immediate字段为补码值，所以它可以表示从-2到2m-1之间的整数。当I型格式用于加载指令时，immediate字段表示一个字节偏移量，所以加载双字指令可以取相对于基址寄存器d中基地址偏移±(21或2048)字节（±(2或256）个双字)的任何双字。我们发现，超过32个寄存器在这种格式下使用起来会很困难，因为rd和rs1字段都需要增添额外的一位，这导致一个字是不够的。



#### S型

> 用于存储双字指令sd的指令格式，它需要两个源寄存器（用于基址和存储数据)和一个用于地址偏移量的immediate字段。

![image-20220725163824001](https://s2.loli.net/2022/07/25/j4ZfCxYuzGpcwPS.png)

S型格式的12位immediate字段分成了两个字段，低5位和高7位。RISC-V体系结构设计师选择这种设计是因为它能够在所有指令格式中保持rs1和rs2字段在相同的位置。保持尽可能相似的指令格式降低了硬件的复杂性。同样，opcode和funct.3字段也总是保持同样的大小并在同一个位置。



![image-20220725172616305](https://s2.loli.net/2022/07/25/NOVhGMEpW3TXs48.png)

![image-20220725172629561](https://s2.loli.net/2022/07/25/EIi6AST1FugxXny.png)

#### SB型

> RISC-V分支指令使用称为SB型的RISC-V指令格式。这种格式可以表示从-4096到094的分支地址，以2的倍数表示。由于最近的一些原因，它只能跳转到偶数地址。SB型格式包括一个7位操作码、一个3位功能码、两个5位的寄存器操作数(rs1和s2)和一个12位地址立即数。该地址使用特殊的编码方式，简化了数据通路设计，但使组装变得复杂。

如：

```assembly
bne x10, x11, 2000	//if x10 != x11, go to location 2000 = 011111010000_ten
```

可以组装为这种格式

![image-20220726150639110](https://s2.loli.net/2022/07/26/52VN8A1746wbXpW.png)

其中条件分支的操作码是1100111_2，而`bne`的funct3码是001_2。



#### UJ型

> 无条件跳转-链接指令(ja1)是唯一使用UJ型格式的指令。

该指令由一个7位操作码、一个5位目标寄存器操作数(rd)和一个20位地址立即数组成。链接地址，即ja1之后的指令的地址，被写入rd中。与SB型格式一样，UJ型格式的地址操作数使用特殊的立即数编码方式，它不能编码奇数地址。所以，

```ass
jal x0, 2000	//go to 1ocation 2000_ten=0111 1101 0000
```

被组装为这种格式：

![image-20220726151242386](https://s2.loli.net/2022/07/26/CIRhjt71qHn8c4Q.png)



#### 总结

![image-20220726152748569](https://s2.loli.net/2022/07/26/hZQVAnEOKL4sbH7.png)





## 汇编代码

### 基础运算

**相加操作：**

```c
a = b + c + d + e
```

编译后：

```assembly
add a, b, c		// The sum of b and c is placed in a
add a, a, d		// The sum of b,c,and d is now in a
add a, a, e		// The sum of b,c,d,and e is now in a
```



**复杂赋值语句**

```c
f = ( g + h ) - ( i + j );
```

编译后：

```assembly
add t0, g, h	// temporary variable t0 contains g h
add t1, i, j	// temporary variable tl contains i+j
sub f, t0, tl	// f gets to tl,which is (g h)-(i j)
```



**操作数在内存中**

```c
A[12] = h + A[8];
```

编译后：

假设变量h存放在寄存器x21中，数组A的基址存放在寄存器x22中。

```assembly
1d x9, 64(×22)	// Temporary reg x9 gets A[8]
add x9, x21,x9	// Temporary reg x9 gets h A[8]
sd x9, 96(x22)	// Stores h A[8]back into A[12]
```

> 字节寻址也会影响数组下标。为了在上面的代码中获得正确的字节地址，加到基址寄存器×22的偏移量必须是8×8或64，以便取地址将选择A[8]而不是[8/8]。



**常数**

> 我们需要将常数从内存中取出才能使用

例如，要将常数4加到寄存器×22，可以使用以下代码：

假设x3+AddrConstant4是常数4的内存地址。

```assembly
ld x9 .AddrConstant4(x3)	// x9 constant 4
add x22, x22, x9			// x22 = x22 + x9 (where x9 == 4)
```

或使用立即数

```assembly
addi x22, ×22, 4	// ×22 = x22 + 4
```



### 逻辑操作

- AND（于）：两个操作数的逻辑按位操作，只有在两个操作数中的对应位都是1时，结果的对应位才是1。

  ```assembly
  and x9, x10, x11	//reg x9 reg x10 reg x11
  ```

- OR（或）：两个操作数的逻辑按位操作，如果两个操作数中的对应位有一个为1，则结果的对应位为1。

  ```assembly
  or x9, x10, x11		//reg x9 reg x10 reg x11
  ```

- NOT（按位取反）：一个操作数的逻辑按位取反操作，也即是说，把每个1替换为0，把每个0替换为1。

- XOR（异或）：两个操作数的逻辑按位操作，用于计算两个操作数的异或。也就是说，只有两个操作数的对应位不同时，它才会计算为1。

  > 为了保持三操作数格式，RISC-V的设计者决定引入指令XOR(异或)来取代NOT。因为异或是在两个操作数对应位相同时设0，不同时设1，所以NOT等价于异或111.…111。

  ```
  xor x9, x10, x12 		//reg x9 reg x10 reg x12
  ```

  

### 条件分支

**相等则分支**

```assembly
beq rs1, rs2, L1
```

该指令表示如果寄存器rs1中的值等于寄存器rs2中的值，则转到标签为L1的语句执行。助记符`beq`代表相等则分支。

**不等则分支**

```
bne rsl, rs2, L1
```

该指令表示如果寄存器rs1中的值不等于寄存器rs2中的值，则转到标签为L1的语句执行。助记符`bne`代表不等则分支。



例如：

在下面的代码段中，f、g、h、i和j是变量。如果五个变量f到j对应于x19到x23这5个寄存器，

```c
if ( i == j ) 
    f = g + h; 
else 
    f = g - h;
```

![image-20220726105459824](https://s2.loli.net/2022/07/26/4DZbdL7ijrOBPC3.png)

代码如下：

```assembly
bne x22, x23, E1se		//go to Else if i≠j
add x19, x20, x21		//f = g + h (skipped if i≠j)
beg x0, x0, Exit		//if 0 =0,go to Exit
Else: sub x19, x20, x21	//f = g - h (skipped if i = j)
Exit:
```

第一个表达式比较寄存器中两个变量是否相等。如果i和j相等则跳转，那么需要一条beq指令。一般来说，如果我们测试相反的条件来进行跳转，代码将更有效率，那么需要一条bne指令。

if语句的结尾部分,本例引入了另一种分支，通常称为无条件分支。该指令表示在遇到该指令时，程序必须分支。在RISC-V中表达无条件分支的一种方法是使用条件始终为真的条件分支。

在该指令之后还需Exit标签，表示if-then-else编译后的代码结束.。



### 移位

一个双字中的所有位都向左或向右移，用填充空出来的位。对应于左移的是右移。这两条RISC-V移位指令的实际名称是左移逻辑立即数(slli)和右移逻辑立即数(srli)。

```
s11i x11, x19, 4	// reg xll = reg x19 << 4 bits
```

表示9，并且9×16=144，刚好是第二个二进制的值。RISC-V提供了第三种类型的移位招令—算术右移(srai)。这个变体与srli很相似，但它不是用零填充空出的左边的位而是用原来的符号位来填充。它还提供了三个移位操作的变体：sll、srl和sra。它们从寄存器中取出移位的位数，而不是从立即数中。

### 循环

对于常见while循环

```c
while ( save[i] == k )
	i += 1;
```

假设`i`和`k`对应于寄存器x22和x24，数组的基址保存在x25中。

```assembly
Loop: s11i x10, x22, 3	// 左移3位相当于乘以2^3,获取偏移量,存放在临时寄存器x10中
add x10, x10, x25		// 和数组基址相加得到save[i]的地址
1dx 9, 0(x10)			// 把save[i]的值取出 放在x9里
bne x9, x24, Exit		// 如果save[i]≠k 则退出
addi x22, x22, 1		// i = i + 1
beq x0, x0, Loop 		// 继续循环
Exit:
```

第一步是将save[i]加载到临时寄存器中。在将save[i]加载到临时寄存器之前，需要得到它的地址。在将i加到数组save的基址以形成地址之前，由于字节寻址问
题，必须将索引i乘以8。幸运的是，我们可以使用左移，因为左移3位相当于乘以2^3(参见上一节)。我们需要给指令添加标签Loop，以便我们可以在循环结尾跳转回该指令。

### 边界检查

利用该简便方法可以降低下标越界检查的开销：如果x20≥×11或×20是负数则跳转到`IndexoutofBounds`。

```assembly
bgeu x20, x11, IndexOutofBounds 
```

### case/switch语句

大多数编程语言都包含case或switch语句，允许程序员根据某个值选择多个分支中的一个。实现switch的最简单方法是通过一系列的条件测试，将switch语句转换成if-then-else语句。

有时，另一种更有效的方法是编码形成指令序列的地址表，称为分支地址表或分支表，程序只需要索引到表中，然后跳转到合适的指令序列。因此，分支表只是一个双字数组，其中包含与代码中的标签对应的地址。该程序将分支表中的相应条目加载到寄存器中，然后需要使用寄存器中的地址进行跳转。为了支持这种情况，RISC-V这类指令系统包含一个间接跳转指令，该指令对寄存器中指定的地址执行无条件跳转。在RISC-V中，跳转一链接指令(jalr)用于此目的。我们将在下一节中看到这种多功能指令更多常见的使用方式。

> 虽然在类似C和Java这样的编程语言中有很多决策和循环的语句，但在指令系统级别实现它们的基础语句是条件分支。

## 计算机硬件对过程的支持

### 过程（函数）

程序执行过程时，须遵循

1. 将参数放在过程可以访问到的位置。
2. 将控制转交给过程。
3. 获取过程所需的存储资源。
4. 执行所需的任务。
5. 将结果值放在调用程序可以访问到的位置。
6. 将控制返回到初始点，因为过程可以从程序中的多个点调用。

RISC-V软件为过程调用分配寄存器时遵循以下约定：

- x10~x17：八个参数寄存器，用于传递参数或返回值。
- x1：一个返回地址寄存器，用于返回到起始点。

除了分配这些寄存器之外，RISC-V汇编语言还包含一个仅用于过程的指令：跳转到某个地址的同时将下一条指令的地址保存到目标寄存器rd。跳转-链接指令(jal)写作：
```
jal x1, ProcedureAddress		//jump to ProcedureAddress and write return address to xl
```

> 跳转一链接指令：跳转到某个地址的同时将下一条指令的地址保存在寄存器（在RISC-V中通常是x1）中的指令。

指令中的链接部分表示指向调用点的地址或链接，以允许该过程返回到合适的地址。存储在寄存器x1中的这个“链接”被称为返回地址。返回地址是必需的，因为同一过程可能在程序的不同部分被调用。为了支持这种情况下的过程返回，类似RISC-V的计算机使用了间接跳转（如上述跳转-链接指令(jalr)),用以处理case语句：

```assembly
jalr x0, 0(x1)
```

> 详细阐述通过使用x作为目标寄存器，跳转-链接指令也可用于实现过程内的无条件跳转。由于×0硬连线为零，其效果是丢弃返回地址：
>
> ```assembly
> jal x0, Label 	//unconditionally branch to Label
> ```

### 使用更多的寄存器

假设对于一个过程，编译器需要比8个参数寄存器更多的寄存器。由于在任务完成后必须掩盖踪迹，调用者所需的所有寄存器都必须恢复到调用该过程之前所存储的值。这种情况是需要将寄存器换出到存储器中的一个例子。

换出寄存器的理想数据结构是**栈(stack)**——一种后进先出的队列。栈需要一个指向栈中最新分配地址的指针，以指示下一个过程应该放置换出寄存器的位置或寄存器旧值的存放位置。在RISC-V中，栈指针(stack pointer)是寄存器x2,也称为`sp`。栈指针按照每个被保存或恢复的寄存器按双字进行调整。栈应用非常广泛，因而传送数据到栈或从栈传输数据都具有专业术语：将数据放入栈中称为压栈，从栈中移除数据称为弹栈。

按照历史惯例，栈按照从高到低的地址顺序“增长”。这就意味着可以通过减栈指针将值压栈；通过增加栈指针缩小栈，从而弹出栈中的值。

如一段c的函数

```c
long long int leaf_example (long long int g,longlong,int h,long long int i,long long int j){
	long long int f;
	f = ( g + h ) - ( i + j );
	return f:
}
```

编译后：

参数变量g、h、i和j对应于参数寄存器×10、x11、x12和x13,f对应于x20。

下一步是保存该过程使用的寄存器。过程体中的赋值语句与之前的例题相同，使用两个临时寄存器(x5和×6)。因此，需要保存三个寄存器：×5、×6和x20。通过在栈中创建三个双字(24字节)空间并将数据存入，实现将旧值“压”入栈中：

```assembly
leaf_example:
addi sp, sp, -24	//在栈中创建空间
sd x5, 16(sp)		//将数据存入栈中
sd x6, 8(sp)
sd x20, 0(sp)
add x5, x10, x11 	//函数体内运算
add x6, x12, x13
sub x20, x5, x6
addi x10, x20, 0 	// 为了返回f，把值复制到一个参数寄存器中
1d x20, 0(sp)		//恢复寄存器的三个旧值：
1d x6, 8(sp)
1d x5, 16(sp)
addi sp, sp, 24		//调整栈大小来删除栈中的临时数据
jalr x0, 0(x1)		//通过一个使用返回地址的跳转寄存器结束过程
```

> 先前示例使用了临时寄存器，并假设其旧值必须被保存和恢复。为了避免保存和恢复一个其值从未被使用过的寄存器（通常为临时寄存器），RISC-V软件将19个寄存器分成两组：
>
> - x5~x7以及x28~×31:临时寄存器，在过程调用中不被被调用者（被调用的过程）保存。
>
> - x8~x9以及x18~x27:保存寄存器(saved register),在过程调用中必须被保存。(一旦使用，由被调用者保存并恢复)
>
>   这一简单约定减少了寄存器换出。在上述例子中，由于调用者不希望在过程调用中保存寄存器×5和6,可以从代码中去掉两次存储和两次载入。但仍须保存并恢复×20，因为被调用者必须假设调用者需要该值。

### 嵌套过程

> 叶子过程：不调用其他过程的过程称为叶子(leaf)过程。

如果所有过程都是叶子过程，情况将会变得简单，但事实并非如此。正如一个侦探任务的一部分可能是雇佣其他侦探一样，被雇佣的侦探进而雇佣更多的侦探，过程调用其他过程也是如此。更进一步，递归过程甚至调用的是自身的“克隆”。就像在过程中使用寄存器时需要小心一样，在调用非叶子过程时必须更加注意。例如，假设主程序调用过程A,参数为3，将值3存入寄存器x10然后使用ja1x1,A。再假设过程A通过ja1x1,B调用过程B,参数为7，也存入x10。由于A尚未结束任务，所以寄存器x10的使用存在冲突。同样在寄存器x1中的返回地址也存在冲突，因为它现在具有的返回地址。除非采取措施阻止这类问题发生，否则该冲突将导致过程A无法返回其调用者。一种解决方法是将其他所有必须保存的寄存器压栈，就像保存寄存器压栈一样。调用者将所有调用后还需要的参数寄存器(x10~x17)或临时寄存器(x5~x7和x28~x31)压栈。被调用者将返回地址寄存器×1和被调用者使用的保存寄存器(x8~×9和x18~x27)压栈。调整栈指针SD以计算压栈寄存器的数量。返回时，从存储器中恢复寄存器并重新调整栈指针。

处理一个计算阶乘的递归过程：

#### TODO



## RISC-V寻址模式总结

![image-20220726151506642](https://s2.loli.net/2022/07/26/yU628lEMTuBQOZ5.png)

1. 立即数寻址，操作数是指令本身的常量。
2. 寄存器寻址，操作数在寄存器中。
3. 基址或偏移寻址，操作数于内存中，其地址是寄存器和指令中的常量之和。
4. PC相对寻址，分支地址是PC和指令中常量之和。

## 机器语言译码

> 有时必须通过逆向工程将机器语言恢复到初始的汇编语言。例如发生“内存转储”(coredump)时。图2-18显示了RISC-V机器语言对应的二进制编码。这个图有助于在汇编语言和机器语言之间进行手动翻译。

![image-20220726151731223](https://s2.loli.net/2022/07/26/oP4bM7zqGOWvFEp.png)

例：

与下面这条机器指令对应的汇编语言语句是什么？
00578833_16

第一步是将十六进制转换为二进制：

0000 0000 0101 0111 1000 1000 0011 0011

要知道如何解释这些位，我们需要确定指令格式，为此首先需要确定操作码。操作码是最右边的7位，即011 0011。在图2-18中搜索该值，我们看到操作码对应于R型算术指令。因此，我们可以将二进制格式解析为下图中列出的字段：

![image-20220726152119561](https://s2.loli.net/2022/07/26/8aDWyqMQ9GsEpid.png)

我们通过查看字段值来译码指令的剩余部分。funct7和funct3字段均为零，表示指令是加法。操作数寄存器rs2字段的十进制值为5，rs1为15，rd为16。这些数字代表寄存器x5、x15和x16。现在我们可以得到汇编指令：

```assembly
add x16, x15, x5
```



## 指令与并行性：同步

当任务之间相互独立时，并行执行更为容易，但通常任务之间需要协作。协作通常意味着一些任务正在写入其他任务必须读取的值。需要知道任务何时完成写入以便其他任务安全地读出，因此任务之间需要同步。如果它们不同步，则存在数据竞争(data race)的危险，那么程序的结果会根据事件发生的次序而改变。



## 翻译并启动程序

![image-20220726155742597](https://s2.loli.net/2022/07/26/tbhiVT2r6XQlLIB.png)

### 编译器

编译器将程序转换为机器能理解的符号形式——汇编语言程序(assembly language program)。高级语言程序比汇编语言使用更少的代码行，因此程序员的工作效率更高。

### 汇编器

由于汇编语言是高层软件的接口，因此汇编器还可以处理机器指令的常见变体，就像这些变体是它自己的指令一样。硬件不需要实现这些指令；然而，它
们在汇编语言中的出现简化了程序转换和编程。这类指令称为伪指令。

如上所述，RISC-V硬件确保寄存器xO总是取O。也就是说，每当使用寄存器×0时，它提供0，如果程序员尝试更改x0中的值，则新值会被直接丢弃。寄存器×用于创建汇编语言指令，将一个寄存器的内容复制到另一个寄存器。因此，即使在RISC-V机器语言中不存在这条指令，RISC-V汇编器也能够识别以下指令：

```assembly
1i x9, 123			//load immediate value 123 into register x9
```

汇编器将此汇编语言指令转换为与以下指令等效的机器语言：

```assembly
addi x9, x0, 123 	//register x9 gets register x0 + 123
```

RISC-V汇编器还将`mv(move)`转换为`addi`指令。从而

```assembly
mv x10, x11 		//register x10 gets register x11
```

变为

```assembly
addi x10, x11, 0 	//register x10 gets register x11 + 0
```





### 链接器

> 链接器：也叫链接编辑器，是一个系统程序，它将独立汇编的机器语言程序组合起来，并解析所有未定义的标签，最终生成可执行文件。

链接器的工作有三个步骤：

1. 将代码和数据模块按符号特征放入内存。
2. 决定数据和指令标签的地址。
3. 修正内部和外部引用。

### 加载器

> 加载器：将目标程序放在主存中以准备执行的系统程序。

现在可执行文件在磁盘上，操作系统将其读取到内存并启动它。加载器在UX系统中
遵循以下步骤：

1. 读取可执行文件首部以确定正文段和数据段的大小。
2. 为正文和数据创建足够大的地址空间。
3. 将可执行文件中的指令和数据复制到内存中。
4. 将主程序的参数（如果有）复制到栈顶。
5. 初始化处理器寄存器并将栈指针指向第一个空闲位置。
6. 跳转到启动例程，将参数复制到参数寄存器中并调用程序的主例程。当主例程返回时，启动例程通过exit系统调用终止程序。

### 动态链接库

> 动态链接库：在执行期间链接到程序的库例程。
