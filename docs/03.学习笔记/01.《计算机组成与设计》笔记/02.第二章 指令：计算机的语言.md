---
title: 第二章 指令：计算机的语言
date: 2022-07-23 18:18:05
permalink: /pages/935f86/
categories: 
  - null
tags: 
  - null
author: 
hidden: true
---

## 指令系统

- 设计原则1：简单源于规整。
- 设计原则2：更少则更快。

- 设计原则3：优秀的设计需要适当的折中。

## 计算机硬件的操作

**相加操作：**

```c
a = b + c + d + e
```

编译后：

```assembly
add a, b, c		// The sum of b and c is placed in a
add a, a, d		// The sum of b,c,and d is now in a
add a, a, e		// The sum of b,c,d,and e is now in a
```



**复杂赋值语句**

```c
f = ( g + h ) - ( i + j );
```

编译后：

```assembly
add t0, g, h	// temporary variable t0 contains g h
add t1, i, j	// temporary variable tl contains i+j
sub f, t0, tl	// f gets to tl,which is (g h)-(i j)
```



**操作数在内存中**

```c
A[12] = h + A[8];
```

编译后：

假设变量h存放在寄存器x21中，数组A的基址存放在寄存器x22中。

```assembly
1d x9, 64(×22)	// Temporary reg x9 gets A[8]
add x9, x21,x9	// Temporary reg x9 gets h A[8]
sd x9, 96(x22)	// Stores h A[8]back into A[12]
```

> 字节寻址也会影响数组下标。为了在上面的代码中获得正确的字节地址，加到基址寄存器×22的偏移量必须是8×8或64，以便取地址将选择A[8]而不是[8/8]。



**常数**

> 我们需要将常数从内存中取出才能使用

例如，要将常数4加到寄存器×22，可以使用以下代码：

假设x3+AddrConstant4是常数4的内存地址。

```assembly
ld x9 .AddrConstant4(x3)	// x9 constant 4
add x22, x22, x9			// x22 = x22 + x9 (where x9 == 4)
```

或使用立即数

```assembly
addi x22, ×22, 4	// ×22 = x22 + 4
```



## 有符号数与无符号数

无符号数：

![image-20220725161510072](https://s2.loli.net/2022/07/25/325wWZvSmoielQC.png)

有符号数

![image-20220725161545914](https://s2.loli.net/2022/07/25/f2XDZIQ4xdliP3k.png)

![image-20220725161606828](https://s2.loli.net/2022/07/25/UCkXwrMLEqeycxT.png)

> 二进制补码表示的优点是，所有负数的最高有效位都为1。因此，硬件只需要检测这一位就可以查看是正数还是负数（数字O被认为是正数）。这个位通常被称为符号位(sign bit)。理解了符号位的作用，就可以用每位数值乘以2的幂之和来表示正负数的64位数：



**相反数**

![image-20220725161813679](https://s2.loli.net/2022/07/25/vFPHuZ5K8IdhTRb.png)



## 机器中的指令表示

对于

```assembly
add x9, x20, x21
```

十进制指令表示为

![image-20220725162536164](https://s2.loli.net/2022/07/25/KZ2k7umtFAps6MB.png)



一条指令的每一段称为一个字段。第一、第四和第六个字段(0、0和51)组合起来告诉RISC-V计算机该指令执行加法操作。第二个字段给出了作为加法运算的第二个源操作数的寄存器编号(21表示x21)，第三个字段给出了加法运算的另一个源操作数(20代表x20)。第五个字段存放要接收总和的寄存器编号(9代表x9)。因此，该指令将寄存器x20和寄存器x21相加并将和存放在寄存器x9中。

该指令也可表示为二进制的形式：

![image-20220725162638369](https://s2.loli.net/2022/07/25/HQCmK2cUP3Rakd6.png)



### RISC-V字段

#### R型

![image-20220725162753452](https://s2.loli.net/2022/07/25/lm7RyD1gdtAWqrI.png)



- funct7:一个另外的操作码字段。
- rs2:第二个源操作数寄存器。

- rs1：第一个源操作数寄存器。
- funct3：一个另外的操作码字段。
- rd：目的操作数寄存器，用来存放操作结果。
- opcode(操作码)：指令的基本操作，这个缩写是它的惯用名称。

#### I型

> 用于带一个常数的算术指令（例如addi)以及加载指令。

![image-20220725163606316](https://s2.loli.net/2022/07/25/ANoLzbYP8eTaUSO.png)

12位immediate字段为补码值，所以它可以表示从-2到2m-1之间的整数。当I型格式用于加载指令时，immediate字段表示一个字节偏移量，所以加载双字指令可以取相对于基址寄存器d中基地址偏移±(21或2048)字节（±(2或256）个双字)的任何双字。我们发现，超过32个寄存器在这种格式下使用起来会很困难，因为rd和rs1字段都需要增添额外的一位，这导致一个字是不够的。



#### S型

> 用于存储双字指令sd的指令格式，它需要两个源寄存器（用于基址和存储数据)和一个用于地址偏移量的immediate字段。

![image-20220725163824001](https://s2.loli.net/2022/07/25/j4ZfCxYuzGpcwPS.png)

S型格式的12位immediate字段分成了两个字段，低5位和高7位。RISC-V体系结构设计师选择这种设计是因为它能够在所有指令格式中保持rs1和rs2字段在相同的位置。保持尽可能相似的指令格式降低了硬件的复杂性。同样，opcode和funct.3字段也总是保持同样的大小并在同一个位置。



![image-20220725172616305](https://s2.loli.net/2022/07/25/NOVhGMEpW3TXs48.png)

![image-20220725172629561](https://s2.loli.net/2022/07/25/EIi6AST1FugxXny.png)

### 逻辑操作

- AND（于）：两个操作数的逻辑按位操作，只有在两个操作数中的对应位都是1时，结果的对应位才是1。
- OR（或）：两个操作数的逻辑按位操作，如果两个操作数中的对应位有一个为1，则结果的对应位为1。
- NOT（按位取反）：一个操作数的逻辑按位取反操作，也即是说，把每个1替换为0，把每个0替换为1。
- XOR（异或）：两个操作数的逻辑按位操作，用于计算两个操作数的异或。也就是说，只有两个操作数的对应位不同时，它才会计算为1。

### 条件分支指令

**相等则分支**

```assembly
beq rs1, rs2, L1
```

该指令表示如果寄存器rs1中的值等于寄存器rs2中的值，则转到标签为L1的语句执行。助记符beq代表相等则分支。

**不等则分支**

```
bne rsl, rs2, L1
```

该指令表示如果寄存器rs1中的值不等于寄存器rs2中的值，则转到标签为L1的语句执行。助记符bne代表不等则分支。
